#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Nov 17 14:05:23 2023

@author: mg
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import pandas as pd
from ttkthemes import ThemedTk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from trained_classifier import mtrain_classifier
from malware_classifier import is_malware
from peview_extraction import extract_infos
from data_addition import add_new_data_to_dataset, compare_data_columns
from sklearn.metrics import ConfusionMatrixDisplay
from PIL import Image, ImageTk

class MalwareClassifierApp:
    def __init__(self, master):
        self.master = ThemedTk(theme="radiance")
        self.master.title("UTRGV: Malware Classification System")

        #Variables for trained classifier and feature vector.
        self.trained_classifier = None
        self.feature_vector = None

        #Initialize original_data.
        self.original_data = pd.read_csv("MalwareData.csv", sep="|")

        #Initialize StringVar for metrics display.
        self.accuracy_value = tk.StringVar(value="N/A")
        self.precision_value = tk.StringVar(value="N/A")
        self.recall_value = tk.StringVar(value="N/A")
        self.f1_value = tk.StringVar(value="N/A")

        #Load and display logo.
        self.load_logo()

        #Create and GUI components.
        self.create_tabs()

    def set_application_icon(self):
        try:
            icon_path = '//UTRGV-Vaqueros-Logo-1984.ico'
            self.master.iconbitmap(icon_path)
        except Exception as e:
            print(f"Error setting app icon: {e}")

    def load_logo(self):
        try:
            logo_path = 'utrgv_vaqueros_logo_alternate.png'

            #Open with Pillow.
            logo_pil = Image.open(logo_path)

            #Resize image.
            logo_pil_resized = logo_pil.resize((logo_pil.width // 2, logo_pil.height // 2), Image.ANTIALIAS)
            logo_image = ImageTk.PhotoImage(logo_pil_resized)

            #Add a title.
            title_label = ttk.Label(self.master, text="Welcome to the Malware Classifier.", font=("Helvetica", 30),
                                    justify='center')
            title_label.pack(pady=10)

            #Label to display the logo.
            logo_label = ttk.Label(self.master, image=logo_image)
            logo_label.image = logo_image
            logo_label.pack(pady=10)

            #Add a title.
            title_label = ttk.Label(self.master,
                                    text="This uses Support Vector Machines to classify a file.\nYou may specify a KERNEL and a MAX ITERATION.",
                                    font=("Helvetica", 22), justify='center')
            title_label.pack(pady=10)

        except Exception as e:
            print(f"Error loading logo: {e}")

    def create_datasets_tab(self, dataset_tab):
        ttk.Label(dataset_tab, text="Dataset Information:").pack()

        #Display the number of samples in the dataset.
        ttk.Label(dataset_tab, text=f"Number of Samples: {len(self.original_data)}").pack()

        #Scrolled canvas.
        canvas = tk.Canvas(dataset_tab)
        scrollbar = ttk.Scrollbar(dataset_tab, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        #Dataset Columns.
        ttk.Label(scrollable_frame, text="Dataset Columns:", font=("Helvetica", 14, "bold")).pack()
        columns_text = ttk.Label(scrollable_frame, text=str(self.original_data.columns), wraplength=6000)
        columns_text.pack()

        #Head.
        ttk.Label(scrollable_frame, text="Dataset Head:", font=("Helvetica", 14, "bold")).pack()
        head_text = ttk.Label(scrollable_frame, text=str(self.original_data.head()), wraplength=6000)
        head_text.pack()

        #Tail.
        ttk.Label(scrollable_frame, text="Dataset Tail:", font=("Helvetica", 14, "bold")).pack()
        tail_text = ttk.Label(scrollable_frame, text=str(self.original_data.tail()), wraplength=6000)
        tail_text.pack()

        #Summary Statistics.
        ttk.Label(scrollable_frame, text="Summary Statistics:", font=("Helvetica", 14, "bold")).pack()
        stats_text = ttk.Label(scrollable_frame, text=str(self.original_data.describe()), wraplength=6000)
        stats_text.pack()

        #Missing Values DEBUG.
        ttk.Label(scrollable_frame, text="Missing Values:", font=("Helvetica", 14, "bold")).pack()
        missing_values_text = ttk.Label(scrollable_frame, text=str(self.original_data.isnull().sum()), wraplength=6000)
        missing_values_text.pack()

        #Pack the canvas and scrollbar together.
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

    def create_tabs(self):
        self.notebook = ttk.Notebook(self.master)

        #Create home tab.
        home_tab = ttk.Frame(self.notebook)
        self.create_home_tab(home_tab)
        self.notebook.add(home_tab, text='Home')

        #Create metrics tab.
        metrics_tab = ttk.Frame(self.notebook)
        self.create_metrics_tab(metrics_tab)
        self.notebook.add(metrics_tab, text='Metrics')

        # reate dataset info tab.
        dataset_tab = ttk.Frame(self.notebook)
        self.create_datasets_tab(dataset_tab)
        self.notebook.add(dataset_tab, text='Dataset Info')

        #Pack the notebook.
        self.notebook.pack(expand=True, fill=tk.BOTH)

    def create_home_tab(self, home_tab):
        #Select Kernel. (USER)
        self.kernel_label = ttk.Label(home_tab, text="Select Kernel:")
        self.kernel_label.pack()
        self.kernel_choices = ["linear", "rbf", "poly"]
        self.kernel_var = tk.StringVar(value=self.kernel_choices[0])
        self.kernel_dropdown = ttk.Combobox(home_tab, textvariable=self.kernel_var, values=self.kernel_choices, state="readonly")
        self.kernel_dropdown.bind("<<ComboboxSelected>>", self.update_options)
        self.kernel_dropdown.pack()

        #Max_iter for all kernels.
        self.max_iter_label = ttk.Label(home_tab, text="Max Iter:")
        self.max_iter_label.pack()

        self.max_iter_entry = ttk.Entry(home_tab)
        self.max_iter_entry.insert(0, "300")  #Set default.
        self.max_iter_entry.pack()

        #C parameter.
        self.c_label = ttk.Label(home_tab, text="C:")
        self.c_label.pack()
        self.c_entry = ttk.Entry(home_tab)
        self.c_entry.insert(0, "1.0")  #Set default.
        self.c_entry.state(['readonly'])  #Read-only.
        self.c_entry.pack()

        #Degree parameter (only for poly kernel).
        self.degree_label = ttk.Label(home_tab, text="Degree:")
        self.degree_label.pack()

        self.degree_entry = ttk.Entry(home_tab)
        self.degree_entry.insert(0, "3")  # Set default.
        self.degree_entry.state(['readonly'])  #Read-only.
        self.degree_entry.pack()

        #Gamma parameter (for rbf and poly kernels).
        self.gamma_label = ttk.Label(home_tab, text="Gamma:")
        self.gamma_label.pack()

        self.gamma_entry = ttk.Entry(home_tab)
        self.gamma_entry.insert(0, "auto")  #Set default.
        self.gamma_entry.state(['readonly'])  #Read-only.
        self.gamma_entry.pack()

        #Upload file button.
        self.upload_button = ttk.Button(home_tab, text="Upload File", command=self.upload_file)
        self.upload_button.pack()

        #Train button.
        self.train_button = ttk.Button(home_tab, text="Train", command=self.train_classifier)
        self.train_button.pack()

        #Classify button.
        self.classify_button = ttk.Button(home_tab, text="Classify", command=self.classify_file)
        self.classify_button.pack()

        #Add New Data button.
        self.add_data_button = ttk.Button(home_tab, text="Add New Data", command=self.add_new_data)
        self.add_data_button.pack()

    def create_metrics_tab(self, metrics_tab):
        ttk.Label(metrics_tab, text="Accuracy:").pack()
        ttk.Label(metrics_tab, textvariable=self.accuracy_value).pack()

        ttk.Label(metrics_tab, text="Precision:").pack()
        ttk.Label(metrics_tab, textvariable=self.precision_value).pack()

        ttk.Label(metrics_tab, text="Recall:").pack()
        ttk.Label(metrics_tab, textvariable=self.recall_value).pack()

        ttk.Label(metrics_tab, text="F1 Score:").pack()
        ttk.Label(metrics_tab, textvariable=self.f1_value).pack()

        ttk.Label(metrics_tab, text="Confusion Matrix:").pack()
        self.confusion_matrix_frame = ttk.Frame(metrics_tab)
        self.confusion_matrix_frame.pack()
        self.confusion_matrix_text = tk.Text(self.confusion_matrix_frame, wrap=tk.WORD, height=10, width=40,state=tk.DISABLED)
        self.confusion_matrix_text.pack()

    def update_options(self, event):
        selected_kernel = self.kernel_var.get()

        #Hide all options.
        self.max_iter_label.pack_forget()
        self.max_iter_entry.pack_forget()
        self.c_label.pack_forget()
        self.c_entry.pack_forget()
        self.degree_label.pack_forget()
        self.degree_entry.pack_forget()
        self.gamma_label.pack_forget()
        self.gamma_entry.pack_forget()

        #Show options based on kernel.
        if selected_kernel == "linear":
            self.max_iter_label.pack()
            self.max_iter_entry.pack()
            self.c_label.pack()
            self.c_entry.pack()
        elif selected_kernel == "rbf" or selected_kernel == "poly":
            self.max_iter_label.pack()
            self.max_iter_entry.pack()
            #Display C.
            self.c_label.pack()
            self.c_entry.pack()
            if selected_kernel == "poly":
                self.degree_label.pack()
                self.degree_entry.pack()
            self.gamma_label.pack()
            self.gamma_entry.pack()

    def upload_file(self):
        file_path = filedialog.askopenfilename(title="Select File to Upload", filetypes=(("Executable Files", "*.exe"), ("Dynamic Link Libraries", "*.dll"),))
        if file_path:
            #Extract features from the uploaded file using peview.
            self.feature_vector = extract_infos(file_path)
            messagebox.showinfo("File Uploaded", "File has been uploaded successfully.")

    def train_classifier(self):
        #Get user-selected kernel, max_iter, degree, C, and gamma.
        selected_kernel = self.kernel_var.get()
        max_iter = self.max_iter_entry.get()

        if selected_kernel == "linear":
            degree_value = "N/A"  #Not applicable for linear.
        else:
            degree_value = int(self.degree_entry.get())

        c_value = float(self.c_entry.get())
        gamma_value = self.gamma_entry.get()

        #Call the train_classifier function.
        self.trained_classifier = mtrain_classifier("MalwareData.csv", "|", selected_kernel, max_iter, degree_value, c_value, gamma_value)
        self.display_training_metrics()
        messagebox.showinfo("Training Complete", "Classifier has been trained successfully.")

    def display_training_metrics(self):
        #Display metrics.
        accuracy = self.trained_classifier.metrics.get('accuracy', "N/A")
        precision = self.trained_classifier.metrics.get('precision', "N/A")
        recall = self.trained_classifier.metrics.get('recall', "N/A")
        f1_score = self.trained_classifier.metrics.get('f1_score', "N/A")

        self.accuracy_value.set(f"{accuracy:.2f}")
        self.precision_value.set(f"{precision:.2f}")
        self.recall_value.set(f"{recall:.2f}")
        self.f1_value.set(f"{f1_score:.2f}")

        #Display confusion matrix as plot.
        cm = self.trained_classifier.metrics.get('confusion_matrix', None)
        if cm is not None:
            #Clear existing frame from set.
            for widget in self.confusion_matrix_frame.winfo_children():
                widget.destroy()

            #Create a figure and display confusion matrix.
            fig, ax = plt.subplots(figsize=(8, 8))
            disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=self.trained_classifier.classes_)
            disp.plot(ax=ax)
            plt.tight_layout()

            #Embed the figure in the window.
            canvas = FigureCanvasTkAgg(fig, master=self.confusion_matrix_frame)
            canvas_widget = canvas.get_tk_widget()
            canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=1)

            #Add a toolbar, not necessary but maybe with furture use / different dataset ie when cm is more than 2x2 just call/pack.
            toolbar = NavigationToolbar2Tk(canvas, self.confusion_matrix_frame)
            canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=1)

            canvas.draw()

        else:
            ttk.Label(self.confusion_matrix_frame, text="Confusion matrix not available.").pack()

    def classify_file(self):
        if not self.feature_vector:
            messagebox.showwarning("Error", "Upload a file before classification.")
            return

        #Ensure the feature vector has the same order of columns as during training.
        if self.trained_classifier and hasattr(self.trained_classifier, 'scaler'):
            try:
                feature_vector_normalized = self.trained_classifier.scaler.transform([self.feature_vector])
            except ValueError as e:
                messagebox.showwarning("Error", f"Error during normalization: {e}")
                return

            #Use the trained classifier to predict whether the file is malware or not.
            prediction = is_malware(feature_vector_normalized, self.trained_classifier)

            #Display the classification result.
            if prediction:
                result = "Malware"
            else:
                result = "Legitimate"

            messagebox.showinfo("Classification Result", f"The file is classified as: {result}")

    def add_new_data(self):
        file_path = filedialog.askopenfilename(title="Select File with New Data", filetypes=(("CSV Files", "*.csv"),))
        if file_path:
            #Load the new data.
            new_data = pd.read_csv(file_path, sep="|")

            #Check if columns match.
            if compare_data_columns(new_data, self.original_data):
                #Append the new data to the existing dataset (MalwareData.csv).
                combined_data = pd.concat([self.original_data, new_data], ignore_index=True)

                #Print shape statements for debugging.
                print("Original Data Shape:", self.original_data.shape)
                print("Combined Data Shape:", combined_data.shape)

                #Save the combined data back to the CSV file.
                combined_data.to_csv("MalwareData.csv", sep="|", index=False)

                messagebox.showinfo("Data Added", "New data has been added to the dataset.")
            else:
                #Print shape statements for debugging.
                print("Original Data Shape:", self.original_data.shape)
                print("Combined Data Shape:", self.original_data.shape)

                messagebox.showerror("Error", "Columns of the new data do not match the existing dataset. Data was not added to the Database. \n :(")

if __name__ == "__main__":
    app = MalwareClassifierApp(None)
    app.master.mainloop()

